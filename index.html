<!-- Copyright 2010 Robert Scott Dionne. All Rights Reserved. -->
<html>
  <head>
    <script src="discoball.js" type="application/javascript"></script>
    <script id="quatlib" type="x-shader/x-vertex">
      vec3 rotate(vec4 q, vec3 v) {
        vec3 r = q.xyz;
        float a = q.w;
        return v + cross(2.0 * r, cross(r, v) + a * v);
      }

      vec4 inverse(vec4 q) {
        return vec4(vec3(-1.),1.)*q/dot(q,q);
      }

    </script>
    <script id="v0" type="x-shader/x-vertex">
      // Per skeleton uniforms
      uniform mat4 uProjection;

      // Per limb uniforms
      uniform vec4 uTransform[2];
      uniform vec4 uCamera[2];

      // Per vertex attributes
      attribute vec3 aPosition;
      attribute vec3 aNormal;
      attribute vec3 aColor;
      attribute vec2 aTexCoord;

      // Per vertex varyings
      varying vec3 vPosition;
      varying vec3 vNormal;
      varying vec3 vTexCoord;
      varying vec3 vColor;

      void main() {
        // Dual quaternion transformation code adapted from
        // Geometric Skinning with Approximate Dual Quaternion Blending:
        // http://isg.cs.tcd.ie/kavanl/papers/sdq-tog08.pdf
        // See dqsFast():
        // http://isg.cs.tcd.ie/kavanl/dq/dqs.cg
        float len = length(uTransform[0]);
        vec4 transf[2];
        transf[0] = uTransform[0] / len;
        transf[1] = uTransform[1] / len;
        vec3 pos = rotate(transf[0], aPosition);
        vec3 transl = 2.0 * (transf[0].w * transf[1].xyz -
            transf[1].w * transf[0].xyz + cross(transf[0].xyz, transf[1].xyz));
        pos += transl;

        len = length(uCamera[0]);
        vec4 camera[2];
        camera[0] = uCamera[0] / len;

        vNormal = rotate(transf[0], aNormal);
        vTexCoord = rotate(inverse(camera[0]), reflect(pos, vNormal));
        vColor = aColor;
        gl_Position = uProjection * vec4(pos, 1.0);
        vPosition = pos;
      }
    </script>
    <script id="f0" type="x-shader/x-fragment">
      uniform highp vec3 uLightPos;
      uniform samplerCube uTexture;

      // Per fragment varyings
      varying highp vec3 vPosition;
      varying highp vec3 vNormal;
      varying highp vec3 vTexCoord;
      varying lowp vec3 vColor;

      const highp float AMBIENT = 0.25;

      void main() {
        highp vec3 light = uLightPos - vPosition;
        highp float spec =
            pow(clamp(-dot(normalize(vPosition),
                normalize(reflect(-light, vNormal))), 0., 1.), 99.0);
        highp float dot = dot(normalize(light), vNormal);
        highp vec3 diffuse = vec3(max(dot, AMBIENT));
        highp vec3 color = textureCube(uTexture, normalize(vTexCoord)).xyz
            * vColor;
        gl_FragColor = vec4(diffuse * color + vec3(spec), 1.);
      }
    </script>
    <script id="v1" type="x-shader/x-vertex">
      // Per skeleton uniforms
      uniform mat4 uProjection;
      uniform highp vec3 uLightPos;

      // Per limb uniforms
      uniform vec4 uTransform[2];
      uniform vec4 uCamera[2];

      // Per vertex attributes
      attribute vec3 aPosition;
      attribute vec3 aNormal;
      attribute vec3 aColor;
      attribute vec2 aTexCoord;

      // Per vertex varyings
      varying vec3 vPosition;
      varying vec3 vNormal;
      varying vec2 vTexCoord;
      varying vec3 vColor;

      void main() {
        // Dual quaternion transformation code adapted from
        // Geometric Skinning with Approximate Dual Quaternion Blending:
        // http://isg.cs.tcd.ie/kavanl/papers/sdq-tog08.pdf
        // See dqsFast():
        // http://isg.cs.tcd.ie/kavanl/dq/dqs.cg
        float len = length(uTransform[0]);
        vec4 transf[2];
        transf[0] = uTransform[0] / len;
        transf[1] = uTransform[1] / len;
        vec3 pos = rotate(transf[0], aPosition);
        vec3 transl = 2.0 * (transf[0].w * transf[1].xyz -
            transf[1].w * transf[0].xyz + cross(transf[0].xyz, transf[1].xyz));
        pos += transl;

        vNormal = rotate(transf[0], aNormal);

        vec4 plane = vec4(vec3(0., 0., 1.), -100.);
        vec3 ab = reflect(pos - uLightPos, vNormal);
        float t = (plane.w - dot(plane.xyz, pos)) / (dot(plane.xyz, ab));
        vec3 q = pos + t * ab;

        if (t <= 0.) {
          q = vec3(0.);
        }

        vTexCoord = aTexCoord;
        vColor = ab;
        gl_Position = uProjection * vec4(q, 1.0);
        vPosition = pos;
      }
    </script>
    <script id="f1" type="x-shader/x-fragment">
      uniform sampler2D uTexture;

      varying highp vec2 vTexCoord;
      varying highp vec3 vColor;

      void main() {
        highp vec3 diffuse = vec3(-dot(normalize(vColor), vec3(0., 0., 1.)));
        diffuse *= texture2D(uTexture, vTexCoord).rgb;
        diffuse = max(vec3(.1), diffuse);
        gl_FragColor = vec4(diffuse, 1.);
      }
    </script>
    <script id="v2" type="x-shader/x-vertex">
      uniform mat4 uProjection;
      uniform vec4 uTransform[2];

      attribute vec3 aPosition;
      attribute vec3 aNormal;

      varying vec3 vPosition;
      varying vec3 vNormal;

      void main() {
        float len = length(uTransform[0]);
        vec4 transf[2];
        transf[0] = uTransform[0] / len;
        transf[1] = uTransform[1] / len;
        vec3 pos = rotate(transf[0], aPosition);
        vec3 transl = 2.0 * (transf[0].w * transf[1].xyz -
            transf[1].w * transf[0].xyz + cross(transf[0].xyz, transf[1].xyz));
        pos += transl;

        vPosition = pos;
        vNormal = rotate(transf[0], aNormal);

        gl_Position = uProjection * vec4(pos, 1.0);
      }
    </script>
    <script id="f2" type="x-shader/x-fragment">
      uniform highp vec3 uLightPos;

      varying highp vec3 vPosition;
      varying highp vec3 vNormal;

      void main() {
        highp vec3 light = normalize(uLightPos - vPosition);
        highp float spec =
            pow(clamp(length(cross(normalize(vPosition),
                normalize(light))), 0., 1.), 99.0);
        gl_FragColor = vec4(vec3(spec), 1.);
      }
    </script>
    <style type="text/css">
      body {
        margin-top: 0px;
        margin-right: 0px;
        margin-bottom: 0px;
        margin-left: 0px;
        color: white;
      }
      .float {
        position: absolute;
        top: 0px;
        left: 0px;
        z-index: -1;
      }
    </style>
  </head>
  <body>
    <div class="float">
      <canvas id="c0"></canvas>
    </div>
  </body>
</html>
